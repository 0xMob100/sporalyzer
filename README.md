# SporalyzerüçÑ
EVM contract size analyzer

## Background

This is a small script created to analyze the sources of contract size in contracts built by `solc`.  The methodology is described in [this post](https://blog.fungify.it/p/introducing-sporalyzer-a-tool-for), which also has a worked example, and sample output.

## Usage

At the moment we are still working on integrations with frameworks like Hardhat and Foundry, but you can download the current code and run it manually via Node.js.
The script takes the following command-line arguments:
- `buildInfoPath`: The filesystem path to the `build-info` JSON file generated by solc at compilation time.  This is usually under the `artifacts/build-info` directory.
- `mode`: This is either `bytecode` or `deployedBytecode` depending on whether you want to analyze the code run at contract creation time (e.g. constructors), or the steady-state code on-chain (i.e. what we usually think of as the main contract code).
- `outputType`: This can be either `listing` or `script`, to set whether you want a simple listing of functions by size, or an 010 Editor script that annotates the bytecode with function names and pretty colors to make it easier to inspect.

### Notes
- If a function size is listed as `?`, that means that no bytecode was attributed to that function by the source map, meaning it effectively had a size of `0`.  However, what this usually actually means in practice is that the function was deduplicated, inlined, or otherwise somehow not attributable as a separate unit, making the `?` size designation a bit more accurate.
- `#utility.yul` is a file generated by `solc` at compile-time with lots of little shims or helper functions.  In the example from the blog post, you can see that it can even contain things like the actual data for error strings.  In many ways it is a reflection of the contents of your contracts.  If you want to inspect it, you can find it in the `build-info` JSON file, under the `generatedSources` key.  Note there there will be two versions: one for `bytecode` and one for `deployedBytecode`, following the distinction outlined above.
